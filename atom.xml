<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>张晓良’s Blog</title>
  <icon>https://hbuzxl.github.io/icon.png</icon>
  
  <link href="https://hbuzxl.github.io/atom.xml" rel="self"/>
  
  <link href="https://hbuzxl.github.io/"/>
  <updated>2026-01-16T09:50:02.867Z</updated>
  <id>https://hbuzxl.github.io/</id>
  
  <author>
    <name>张晓良</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hello World</title>
    <link href="https://hbuzxl.github.io/hello-world/"/>
    <id>https://hbuzxl.github.io/hello-world/</id>
    <published>2026-01-16T09:50:02.867Z</published>
    <updated>2026-01-16T09:50:02.867Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt;</summary>
        
      
    
    
    
    
  </entry>
  
  <entry>
    <title>多 agent 编排——从 OpenCode 到 Oh-My-Opencode</title>
    <link href="https://hbuzxl.github.io/multi-agent-orchestration/"/>
    <id>https://hbuzxl.github.io/multi-agent-orchestration/</id>
    <published>2026-01-16T09:41:04.000Z</published>
    <updated>2026-01-16T09:50:02.867Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-背景介绍"><a href="#1-背景介绍" class="headerlink" title="1. 背景介绍"></a>1. 背景介绍</h2><p>随着大型语言模型（LLM）能力的飞速发展，我们正在进入一个由 AI Agent 驱动的软件开发新时代。Agent，作为能够自主理解、规划并执行复杂任务的智能实体，正逐渐从理论走向实践，深刻改变着开发者与代码交互的方式。从最初的单体 Agent 辅助编码，到如今由多个专业 Agent 协同作战，多 Agent 系统（Multi-Agent Systems）已成为提升开发效率、解决复杂软件工程问题的关键。</p><h3 id="什么是agent"><a href="#什么是agent" class="headerlink" title="什么是agent"></a>什么是agent</h3><p>在人工智能领域，一个 <strong>AI Agent</strong>（智能体）可以被理解为一个能够感知其环境、进行自主决策并执行动作以实现特定目标的计算实体。不同于传统的程序，Agent 具备一定程度的自主性、反应性和社会性。一个典型的 Agent 系统由以下几个核心部分组成：</p><ul><li><strong>感知（Perception）</strong>：通过传感器或数据输入来获取环境状态信息。</li><li><strong>决策（Decision-Making）</strong>：基于其内部知识、目标和感知到的信息，通过推理或学习来选择下一步的行动。</li><li><strong>行动（Action）</strong>：通过执行器（如 API 调用、代码执行）来改变环境状态。</li><li><strong>学习（Learning）</strong>：根据行动的反馈和结果来调整其内部模型和决策逻辑，以提升未来表现。</li></ul><p>对于编码 Agent 而言，其环境是代码库、IDE、终端和外部文档；其行动包括读取&#x2F;写入文件、执行命令、调用工具、与用户交互等；其目标则是根据用户指令完成软件开发任务，例如实现新功能、修复错误或重构代码。</p><p>在当前大语言模型（LLM）的浪潮下，Agent 的概念被进一步发扬光大。LLM 成为了 Agent 强大的“大脑”，使其具备了前所未有的自然语言理解、推理和规划能力。一个基于 LLM 的 Agent 通常能够理解复杂的指令，拆解任务，调用外部工具（如搜索引擎、代码解释器、数据库），并根据结果进行下一步操作，从而完成比单纯的文本生成复杂得多的任务。</p><blockquote><p>Agent &#x3D; 感知 (Perception) + 规划 (Planning) + 行动 (Action)</p></blockquote><h3 id="为什么需要-Multi-Agent？"><a href="#为什么需要-Multi-Agent？" class="headerlink" title="为什么需要 Multi-Agent？"></a>为什么需要 Multi-Agent？</h3><p>随着任务复杂度的提升，单一的、全能型的 Agent 开始暴露出其局限性。</p><table><thead><tr><th>局限性</th><th>描述</th></tr></thead><tbody><tr><td><strong>任务类型单一</strong></td><td>某个模型&#x2F;擅长某类任务，难以覆盖所有场景</td></tr><tr><td><strong>上下文窗口限制</strong></td><td>大型项目难以在一个会话中处理</td></tr><tr><td><strong>并发能力缺失</strong></td><td>无法同时处理多个独立任务</td></tr><tr><td><strong>专业化缺失</strong></td><td>缺乏特定领域的深度知识</td></tr><tr><td><strong>验证不足</strong></td><td>自己的工作难以自我验证</td></tr></tbody></table><p>这与人类社会的发展类似，当任务超出个人能力范围时，就需要团队协作。<strong>多 Agent 系统（Multi-Agent System, MAS）</strong> 正是应对这一挑战的产物。它是一个由多个自主 Agent 组成的系统，这些 Agent 通过相互通信与协作来解决单个 Agent 难以甚至无法完成的复杂问题。</p><p>引入多 Agent 架构主要有以下几点好处：</p><ol><li><p><strong>专业化分工（Specialization）</strong>：现实世界的任务往往需要多种不同的技能。例如，完成一个软件开发需求，可能需要产品经理进行需求分析、架构师进行系统设计、程序员进行编码、测试工程师进行质量保证。在多 Agent 系统中，我们可以设计具有不同“角色”和“专长”的 Agent，如“代码生成 Agent”、“代码审查 Agent”、“安全分析 Agent”等。每个 Agent 专注于其擅长的领域，从而提升整体的效率和产出质量。</p></li><li><p><strong>可扩展性与可维护性（Scalability &amp; Maintainability）</strong>：在单 Agent 系统中增加新功能，往往意味着对其核心 Prompt 和逻辑进行复杂且风险较高的修改。而在多 Agent 系统中，增加新能力通常只需要引入一个新的、具有特定技能的 Agent 即可，对现有系统的侵入性更小。这种模块化的设计使得系统更易于扩展和维护。</p></li><li><p><strong>并行与效率（Parallelism &amp; Efficiency）</strong>：对于可以分解的子任务，多 Agent 系统可以并行执行，显著缩短任务完成时间。例如，在进行技术选型时，可以同时派出多个 Agent 分别研究不同方案的优缺点，然后汇总报告，这远比单个 Agent 依次研究要高效得多。</p></li><li><p><strong>鲁棒性与可靠性（Robustness &amp; Reliability）</strong>：通过引入冗余或多样化的 Agent，系统可以对冲单个 Agent 失败或表现不佳的风险。例如，可以设计一个“评审 Agent”，对其他 Agent 的产出进行检查和验证，形成制衡，从而提高最终结果的可靠性。</p></li></ol><p>正是这些优势，使得多 Agent 系统成为构建下一代智能编码工具的核心架构选择。接下来，我们将深入探讨实现多 Agent 协作的关键——<strong>Agent 编排</strong>。</p><h2 id="多-Agent-编排"><a href="#多-Agent-编排" class="headerlink" title="多 Agent 编排"></a>多 Agent 编排</h2><h3 id="什么是multi-agent"><a href="#什么是multi-agent" class="headerlink" title="什么是multi agent"></a>什么是multi agent</h3><p>多 Agent 系统的核心挑战在于<strong>编排（Orchestration</strong>）——即如何有效地组织和协调多个 Agent 的行为，使其能够作为一个整体高效协作。它定义了 Agent 之间如何分配任务、共享信息、解决冲突以及整合各自的工作成果。一个优秀的编排系统是多 Agent 系统成功的关键，它如同一个经验丰富的项目经理或技术总监，确保整个“Agent 团队”能够高效、有序地运作。</p><h3 id="主流编排模式"><a href="#主流编排模式" class="headerlink" title="主流编排模式"></a>主流编排模式</h3><p>业界已经探索出多种成熟的 Agent 编排模式，每种模式针对不同的任务复杂度、上下文管理需求和协作方式，适用于不同的场景。根据 LangChain 和微软 Azure 等机构的总结，目前主流的编排模式可以归纳为以下几种 [2][3]：</p><table><thead><tr><th align="left">编排模式</th><th align="left">核心思想</th><th align="left">适用场景</th></tr></thead><tbody><tr><td align="left"><strong>顺序编排 (Sequential)</strong></td><td align="left">Agent 像流水线一样按预定顺序依次执行，每个 Agent 处理上一个 Agent 的输出。</td><td align="left">具有明确线性依赖关系的多阶段流程，如“草稿-审查-发布”的内容生成管道。</td></tr><tr><td align="left"><strong>并发编排 (Concurrent)</strong></td><td align="left">多个 Agent 同时对同一任务进行独立处理，最后由一个聚合器整合结果。</td><td align="left">需要从多个独立视角进行分析或评估的任务，如对一个技术方案进行多维度评审。</td></tr><tr><td align="left"><strong>群聊编排 (Group Chat)</strong></td><td align="left">多个 Agent 在一个共享的对话空间中进行开放式讨论和协作，类似于人类的团队会议。</td><td align="left">需要集思广益、迭代创新的复杂问题，如系统架构设计或头脑风暴。</td></tr><tr><td align="left"><strong>交接编排 (Handoff)</strong></td><td align="left">Agent 根据任务的当前状态和需求，动态地将控制权“交接”给最合适的下一个 Agent。</td><td align="left">任务流程不固定，需要根据中间结果进行动态路由的场景。</td></tr></tbody></table><h4 id="Sequential-orchestration"><a href="#Sequential-orchestration" class="headerlink" title="Sequential orchestration"></a>Sequential orchestration</h4><p>将多个 Agent 按照预定义的线性顺序连接起来，形成一个处理管道。</p><p>每个 Agent 的输出是下一个 Agent 的输入，类似于工厂流水线。</p><p>具有明确前后依赖关系的多阶段任务，如“草稿-审查-润色”流程。</p><p>优点：简单直观，易于实现和管理。<br>缺点：灵活性差，不支持并行、分支或迭代。</p><p> <img src="/vx_images/484254806952463.png"></p><h4 id="Subagents-Centralized-orchestration"><a href="#Subagents-Centralized-orchestration" class="headerlink" title="Subagents: Centralized orchestration"></a>Subagents: Centralized orchestration</h4><p>由一个中心化的智能体（Supervisor／Coordinator）负责总体控制，调用多个“子智能体”作为工具执行具体子任务。</p><p>主管 Agent 将子 Agent 作为“工具”来调用，负责收集结果并进行最终决策。子 Agent 通常是无状态的。</p><p>子智能体不自己保存历史对话或状态；主智能体统一组合结果并返回</p><p>优点：控制力强，易于追踪任务状态。<br>缺点：主管 Agent 容易成为性能瓶颈，所有通信都需经过中心节点，延迟较高。</p><p><img src="/vx_images/110925763401614.png"></p><h4 id="Skills-Progressive-disclosure"><a href="#Skills-Progressive-disclosure" class="headerlink" title="Skills: Progressive disclosure"></a>Skills: Progressive disclosure</h4><p>不是严格意义上的多智能体，而是一个智能体根据任务动态加载不同“技能包（Skill）”，这些技能包封装了特定能力的提示、指令和资源。</p><p>单一智能体需具备多种专业能力；</p><p>Skill 被加载后会进入对话历史</p><p>多次调用后容易出现上下文膨胀（token 累积）</p><p><img src="/vx_images/343395396633092.png"></p><h4 id="Handoffs-State-driven-transitions"><a href="#Handoffs-State-driven-transitions" class="headerlink" title="Handoffs: State-driven transitions"></a>Handoffs: State-driven transitions</h4><p>控制权在不同的 Agent 之间根据预设的条件进行转移，形成一个状态机，实现分阶段、顺序性工作流。</p><p>每个 Agent 完成自己的阶段性任务后，将控制权和相关状态“交接”给下一个指定的 Agent。</p><p>具有明确阶段划分和状态转换的流程，如客户支持、多步表单填写。</p><p>优点：流程清晰，状态管理明确，适合顺序解锁能力的场景。<br>缺点：状态管理更复杂，需要精心设计状态存储与切换逻辑。</p><p><img src="/vx_images/524695141655730.png"></p><h4 id="Router-Parallel-dispatch-and-synthesis"><a href="#Router-Parallel-dispatch-and-synthesis" class="headerlink" title="Router: Parallel dispatch and synthesis"></a>Router: Parallel dispatch and synthesis</h4><p>通过一个 Router Agent 对请求进行分类或拆解，并将子任务 并行分发 给多个专用 Agent，并对返回的结果进行综合。</p><p>需要根据输入类型动态选择处理路径，或需要并行查询多个信息源的场景。</p><p>优点：并行效率高，可扩展性好。<br>缺点：如果需要维护对话历史，会产生重复的路由开销。</p><p><img src="/vx_images/123226662304930.png"></p><h4 id="Group-Chat"><a href="#Group-Chat" class="headerlink" title="Group Chat"></a>Group Chat</h4><p>多个 Agent 在一个共享的对话空间中进行交互，每个 Agent 都能看到其他 Agent 的发言并作出反应。</p><p>类似于人类的团队会议，通过多轮对话和讨论来共同解决问题。通常需要一个“管理员”来引导流程。</p><p>需要动态、复杂交互和集体决策的探索性任务。</p><p>优点：高度灵活，能够模拟复杂的协作模式。<br>缺点：难以控制流程，容易出现无效讨论或循环，对 Agent 的协作能力要求高。</p><p><img src="/vx_images/21456100051111.png"></p><h3 id="主流编排框架比较"><a href="#主流编排框架比较" class="headerlink" title="主流编排框架比较"></a>主流编排框架比较</h3><p>除了理论模型，社区也涌现出多个优秀的开源框架，旨在简化多 Agent 系统的开发。其中，<code>LangGraph</code>、<code>CrewAI</code> 和 <code>AutoGen</code> 是目前最受关注的几个框架。</p><ul><li><p><strong>LangGraph</strong>: 由 LangChain 团队开发，它将多 Agent 协作流程建模为图（Graph），其中每个节点代表一个 Agent 或一个工具。这种方式为定义复杂的、带有循环和条件分支的工作流提供了极大的灵活性和控制力。</p></li><li><p><strong>CrewAI</strong>: 专注于通过角色扮演来定义 Agent 的能力和职责。它提供了一种高度声明式的方法来组建“Agent 团队”，强调的是 Agent 的角色定位和团队协作流程。</p></li><li><p><strong>AutoGen</strong>: 由微软研究院推出，其核心理念是让 Agent 通过对话进行协作。它擅长构建能够自动进行多轮对话、协商和共同解决问题的 Agent 系统。</p></li></ul><table><thead><tr><th align="left">维度</th><th align="left">AutoGen (Microsoft)</th><th align="left">CrewAI</th><th align="left">LangGraph (LangChain)</th></tr></thead><tbody><tr><td align="left"><strong>核心理念</strong></td><td align="left"><strong>对话驱动</strong></td><td align="left"><strong>角色驱动</strong></td><td align="left"><strong>图结构驱动</strong></td></tr><tr><td align="left"><strong>架构隐喻</strong></td><td align="left">多个 Agent 通过对话进行协作</td><td align="left">一个分工明确的“小公司”或“团队”</td><td align="left">流程图或状态机</td></tr><tr><td align="left"><strong>设计特点</strong></td><td align="left">以“对话”为中心，Agent 间通过消息传递进行协作，支持灵活的对话模式和人机混合。</td><td align="left">强调“角色”（Role）、“职责”（Duty）和“任务”（Task）的定义，流程固定为“规划-执行-验证”。</td><td align="left">将多 Agent 协作流程建模为图（Graph），每个节点（Node）是一个 Agent 或工具，边（Edge）代表流程的走向，支持复杂的条件分支和循环。</td></tr><tr><td align="left"><strong>适用场景</strong></td><td align="left">探索性任务、快速原型验证、需要人类参与的复杂对话系统。</td><td align="left">目标明确、流程固定的业务自动化任务，如市场分析报告生成、邮件自动化处理等。</td><td align="left">需要对工作流进行精细控制的复杂、动态任务，如需要条件判断、迭代修改的软件开发流程。</td></tr><tr><td align="left"><strong>优缺点</strong></td><td align="left"><strong>优点</strong>：灵活，易于上手，非常适合模拟人类协作。<br><strong>缺点</strong>：流程控制相对困难，容易陷入无效对话。</td><td align="left"><strong>优点</strong>：概念清晰，结构化强，易于理解和管理。<br><strong>缺点</strong>：流程相对固定，灵活性不足。</td><td align="left"><strong>优点</strong>：控制力最强，高度灵活和可定制。<br><strong>缺点</strong>：学习曲线最陡峭，需要开发者具备图的思维模式。</td></tr></tbody></table><h2 id="从-OpenCode-到-Oh-My-OpenCode"><a href="#从-OpenCode-到-Oh-My-OpenCode" class="headerlink" title="从 OpenCode 到 Oh-My-OpenCode"></a>从 OpenCode 到 Oh-My-OpenCode</h2><p>OpenCode 作为一个开源的 AI 编码 Agent，提供了一个坚实的基础平台。而 Oh My OpenCode 作为其社区驱动的增强插件，则在多 Agent 协作与编排方面进行了大刀阔斧的创新，为我们展示了从“单兵作战”到“团队协同”的进化路径。</p><h3 id="OpenCode"><a href="#OpenCode" class="headerlink" title="OpenCode"></a>OpenCode</h3><h4 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h4><p>OpenCode 采用了经典的<strong>客户端-服务器（Client-Server）架构</strong>，这使其具备了良好的跨平台能力和远程协作潜力。其 Agent 系统设计简洁而高效，主要包含两类主 Agent 和一系列辅助性子 Agent。</p><ul><li><p><strong>主 Agent (Primary Agents)</strong>：这是用户直接交互的核心。<code>build</code> Agent 拥有完整的开发权限，负责执行代码修改、文件操作等任务；而 <code>plan</code> Agent 则是一个只读的“分析师”，用于在不产生副作用的前提下探索代码库和规划任务，体现了安全性的考量。</p></li><li><p><strong>子 Agent (Subagents)</strong>：作为主 Agent 的“工具”存在。例如，<code>general</code> Agent 用于处理复杂的多步研究任务，而 <code>explore</code> Agent 则专注于快速的代码库搜索。这些子 Agent 在被调用时执行特定任务，但本身不维护长期状态，其生命周期由主 Agent 完全控制。</p></li></ul><p>这种设计本质上是<strong>中心化编排模式（Coordinator&#x2F;Subagents）</strong> 的一种实现。主 Agent 如同大脑，负责思考和决策，子 Agent 如同四肢，负责执行。所有任务流、信息流都汇聚于主 Agent，由其统一调度。这种模式简单、可控，但主 Agent 容易成为能力的上限和性能的瓶颈。</p><p><img src="/vx_images/362806058679072.png"></p><h4 id="可拓展性"><a href="#可拓展性" class="headerlink" title="可拓展性"></a>可拓展性</h4><p>OpenCode 的前瞻性在于其对扩展性的重视。它通过两大协议来构建其开放生态：</p><ul><li><strong>Agent Client Protocol (ACP)</strong>：这是一套基于 JSON-RPC 的标准化协议，允许第三方开发者将自己的 Agent 接入 OpenCode 的生态系统。这为我们自己的产品集成提供了标准接口。</li><li><strong>Model Context Protocol (MCP)</strong>：该协议旨在标准化 Agent 与外部工具（如 API、数据库）的交互。通过 MCP，我们可以将公司内部的各种服务（如代码分析工具、知识库）封装成 Agent 可用的“工具”，实现能力的复用。</li></ul><p>此外，其内置的<strong>细粒度权限系统（PermissionNext）</strong>，允许对文件访问、命令执行等敏感操作进行 <code>allow</code>、<code>deny</code>、<code>ask</code> 三种级别的控制，为 Agent 的安全运行提供了保障。</p><h3 id="Oh-My-OpenCode"><a href="#Oh-My-OpenCode" class="headerlink" title="Oh-My-OpenCode"></a>Oh-My-OpenCode</h3><h4 id="架构设计-1"><a href="#架构设计-1" class="headerlink" title="架构设计"></a>架构设计</h4><p>如果说 OpenCode 是一个能力全面的“全栈工程师”，那么 Oh My OpenCode 则构建了一个各司其职、高效协作的“精英技术团队”。它在 OpenCode 的基础上，引入了更为复杂的分布式协作架构。</p><p>Oh My OpenCode 的核心是名为 <strong>Sisyphus</strong> 的主编排 Agent。它的角色不再是亲力亲为的执行者，而是一位经验丰富的“技术主管”或“架构师”。其核心职责是<strong>理解用户意图、分解复杂任务，并将其委派给最合适的专家 Agent</strong>。Sisyphus 的工作流程被设计为多阶段的决策过程：</p><ol><li><strong>意图识别</strong>：首先判断用户请求的类型（是简单的问答，还是复杂的开发任务？）。</li><li><strong>代码库评估</strong>：对于开放式任务，它会先评估当前项目的代码质量和风格，以决定后续工作的策略。</li><li><strong>委派决策</strong>：这是最关键的一步。Sisyphus 根据任务的性质，决定是将其分配给一个具有特定“类别（Category）”的通用开发 Agent，还是直接指派给一个高度专业化的 Agent。</li></ol><h4 id="Agent-类型"><a href="#Agent-类型" class="headerlink" title="Agent 类型"></a>Agent 类型</h4><p>Oh My OpenCode 的强大之处在于其丰富的专家 Agent 团队。每个 Agent 都有明确的职责和推荐使用的模型，以达到最佳性价比和效果。</p><table><thead><tr><th><br></th><th><br></th><th><br></th></tr></thead><tbody><tr><td>Agent 角色</td><td>模型</td><td>核心职责</td></tr><tr><td>Sisyphus</td><td><code>Claude Opus 4.5</code></td><td>核心编排者，负责任务的执行和委派。</td></tr><tr><td>Prometheus</td><td><code>Claude Opus 4.5</code></td><td>规划者，负责制定工作计划。</td></tr><tr><td>Oracle</td><td><code>GPT-5.2 Medium</code></td><td>架构师&#x2F;调试专家，提供高层次的调试和复杂问题分析。</td></tr><tr><td>Frontend UI&#x2F;UX Engineer</td><td><code>Gemini 3 Pro Preview</code></td><td>前端专家，负责视觉设计和 UI 实现。</td></tr><tr><td>Document-Writer</td><td><code>Gemini 3 Pro Preview</code></td><td>技术文档撰写</td></tr><tr><td>MultiModal Looker</td><td><code>Gemini 3 Flash</code></td><td>PDF&#x2F; 图像等多模态内容分析</td></tr><tr><td>Librarian</td><td><code>GLM-4.7</code></td><td>研究员，多仓库分析，文档检索与整理。</td></tr><tr><td>Explore</td><td><code>Grok Code</code></td><td>代码上下文探索</td></tr><tr><td>Metis &amp; Momus</td><td><code>Claude Sonnet 4.5</code></td><td>顾问与审查者，负责在规划阶段进行预分析、风险识别和计划校验。</td></tr></tbody></table><h4 id="工作流"><a href="#工作流" class="headerlink" title="工作流"></a>工作流</h4><p><code>Oh My OpenCode</code> 设计了一套完整的工作流，将用户的模糊意图转化为精确的代码实现。这个过程被清晰地划分为三个阶段：</p><p><strong>阶段一：访谈与规划 (Interview &amp; Planning)</strong></p><ul><li><strong>过程</strong>: Prometheus Agent 接管，通过提问、分析现有代码（调用 <code>explore</code> Agent）和查阅文档（调用 <code>librarian</code> Agent），与用户共同明确需求，并将所有讨论内容记录在 <code>.sisyphus/drafts/</code> 目录下。</li><li><strong>产出</strong>: 一份详尽、结构化的任务计划 <code>Markdown</code> 文件，存放在 <code>.sisyphus/plans/</code> 目录下。</li></ul><p><strong>阶段二：计划审查 (Plan Review)</strong></p><ul><li><strong>过程</strong>: Momus 对 Prometheus 生成的计划进行严格审查，如果发现任何模糊、遗漏或不合理之处，会拒绝该计划并要求 Prometheus 重新修订，直到计划完美无缺。</li></ul><p><strong>阶段三：执行 (Execution)</strong></p><ul><li><strong>过程</strong>: Sisyphus Agent 读取最终确定的计划，并创建一个 <code>boulder.json</code> 文件来跟踪任务状态。然后，它会逐一处理计划中的 TODO 事项，通过 <code>sisyphus_task()</code> 函数将具体的子任务委派给最合适的专业 Agent（如将 UI 任务交给 <code>frontend-ui-ux-engineer</code>）。</li><li><strong>特点</strong>: 整个执行过程是<strong>持续的、可恢复的</strong>。即使会话中断，Sisyphus 也能通过 <code>boulder.json</code> 在下次启动时从中断处继续执行。</li></ul><p><img src="/vx_images/380909485572362.png"></p><h4 id="sisyphus-task：编排的核心工具"><a href="#sisyphus-task：编排的核心工具" class="headerlink" title="sisyphus_task：编排的核心工具"></a><code>sisyphus_task</code>：编排的核心工具</h4><p>Sisyphus 通过 <code>sisyphus_task</code> 这一核心工具来下达指令。该工具的设计精妙地体现了其编排思想：</p><ul><li><strong>Category 模式</strong>：对于通用的开发任务，Sisyphus 可以指定一个“类别”，如 <code>visual-engineering</code>（前端视觉）或 <code>ultrabrain</code>（后端逻辑）。系统会据此动态生成一个名为 <code>Sisyphus-Junior-{category}</code> 的子 Agent 来执行任务。这类似于为项目临时组建一个“功能小组”。</li><li><strong>Agent 模式</strong>：对于需要特定专家能力的，Sisyphus 可以直接指定 Agent 名称，如 <code>subagent_type=&quot;oracle&quot;</code>，将任务直接委派给专家。</li></ul><h4 id="后台任务并行执行"><a href="#后台任务并行执行" class="headerlink" title="后台任务并行执行"></a>后台任务并行执行</h4><p>Oh My OpenCode 最具突破性的创新之一是其<strong>后台任务系统（Background Task System）</strong>。当 Sisyphus 发出指令时，可以通过 <code>run_in_background=true</code> 参数，让子 Agent 在一个独立的后台会话中执行任务。这意味着 Sisyphus 可以同时委派多个研究或探索性任务，实现真正的并行工作，极大地提升了信息收集和分析的效率。这套系统包含了完整的任务生命周期管理、并发控制和完成通知机制，是一个工业级的实现。</p><h4 id="技能系统与通信机制"><a href="#技能系统与通信机制" class="headerlink" title="技能系统与通信机制"></a>技能系统与通信机制</h4><ul><li><p><strong>技能系统 (Skills)</strong>：Oh My OpenCode 引入了“技能”的概念，这是一些可复用的、针对特定任务的指令集（如 <code>frontend-ui-ux</code>、<code>playwright</code>）。在委派任务时，Sisyphus 可以为子 Agent “装备”上相应的技能，从而更精确地指导其行为。</p></li><li><p><strong>通信机制</strong>：Oh My OpenCode 的通信是<strong>异步和事件驱动</strong>的。每个后台任务都在独立的会话中运行，通过会话 ID 与父会话关联。任务完成后，通过事件通知 Sisyphus。这种设计解除了主 Agent 与子 Agent 之间的紧耦合，是实现高并发、分布式协作的基础。</p></li></ul><h3 id="OpenCode-对比-Oh-My-OpenCode"><a href="#OpenCode-对比-Oh-My-OpenCode" class="headerlink" title="OpenCode 对比 Oh-My-OpenCode"></a>OpenCode 对比 Oh-My-OpenCode</h3><table><thead><tr><th align="left">维度</th><th align="left">OpenCode</th><th align="left">Oh My OpenCode</th><th align="left">设计演进</th></tr></thead><tbody><tr><td align="left"><strong>编排模式</strong></td><td align="left">中心化编排 (Coordinator)</td><td align="left">分布式协作 + 中心化委派 (Hybrid)</td><td align="left">从“主管-员工”模式演变为“项目经理-专家团队”模式。</td></tr><tr><td align="left"><strong>Agent 角色</strong></td><td align="left">通用执行者 + 辅助工具</td><td align="left">战略编排者 + 高度专业化的专家</td><td align="left">职责更加细分，专业化程度显著提高。</td></tr><tr><td align="left"><strong>并行能力</strong></td><td align="left">有限（依赖于主 Agent 的工具调用方式）</td><td align="left">完整的后台任务系统，支持真并行</td><td align="left">从顺序执行演变为并行执行，效率大幅提升。</td></tr><tr><td align="left"><strong>状态管理</strong></td><td align="left">主 Agent 集中管理</td><td align="left">分布式状态，每个子 Agent 拥有独立会话</td><td align="left">状态管理下沉，降低了中心节点的复杂性，提高了可扩展性。</td></tr><tr><td align="left"><strong>通信方式</strong></td><td align="left">同步工具调用</td><td align="left">异步消息 + 事件驱动</td><td align="left">从紧耦合的同步调用演变为松耦合的异步通信，适应分布式系统。</td></tr></tbody></table><p>通过对比可以看出，Oh My OpenCode 并非简单地对 OpenCode 进行功能增强，而是在其基础上进行了一次深刻的<strong>架构范式升级</strong>。它从一个强大的“个人英雄”，演变成一个懂得如何“领导团队”的“卓越领导者”，其设计思想更贴近于解决真实世界中复杂软件工程问题所需要的团队协作模式。</p><h4 id="ultrawork："><a href="#ultrawork：" class="headerlink" title="ultrawork："></a><code>ultrawork</code>：</h4><p><code>Oh My OpenCode</code> 认识到，并非所有任务都需要用户深度参与规划。为此，它提供了一个名为 <code>ultrawork</code>（或 <code>ulw</code>）的“魔法词”。当用户在提示中包含这个词时，相当于将整个“规划-执行”流程完全委托给 Agent 系统自动完成。这极大地降低了使用门槛，让用户在不想关心细节时，也能享受到多 Agent 编排带来的强大能力。</p><h2 id="讨论-总结"><a href="#讨论-总结" class="headerlink" title="讨论 &amp; 总结"></a>讨论 &amp; 总结</h2><p>引入多 agent 并发执行</p><p>并行多个agent同时开发，最后审核对比</p><p>用的比较多的 CLI 工具</p><p>opencode 有哪些心得&#x2F;好用的点&#x2F;不好用的点</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><p>LangChain. (2026, January 14). <strong>Choosing the Right Multi-Agent Architecture</strong>. LangChain Blog. <a href="https://www.blog.langchain.com/choosing-the-right-multi-agent-architecture/">https://www.blog.langchain.com/choosing-the-right-multi-agent-architecture/</a></p></li><li><p>Microsoft. (2025, July 18). <strong>AI Agent Orchestration Patterns</strong>. Azure Architecture Center: <a href="https://learn.microsoft.com/en-us/azure/architecture/ai-ml/guide/ai-agent-design-patterns">https://learn.microsoft.com/en-us/azure/architecture/ai-ml/guide/ai-agent-design-patterns</a></p></li><li><p>Anthropic (2025, Jun 13). <strong>How we built our multi-agent research system</strong>: <a href="https://www.anthropic.com/engineering/multi-agent-research-system?ref=blog.langchain.com">https://www.anthropic.com/engineering/multi-agent-research-system?ref=blog.langchain.com</a></p></li><li><p><strong>Oh-My-Opencode</strong>: <a href="https://github.com/code-yeongyu/oh-my-opencode">https://github.com/code-yeongyu/oh-my-opencode</a></p></li><li><p><strong>OpenCode</strong>: <a href="https://github.com/anomalyco/opencode">https://github.com/anomalyco/opencode</a></p></li><li><p><strong>opencode security page</strong>：<a href="https://github.com/anomalyco/opencode/security">https://github.com/anomalyco/opencode/security</a></p></li></ul>]]></content>
    
    
    <summary type="html">随着大型语言模型（LLM）能力的飞速发展，我们正在进入一个由 AI Agent 驱动的软件开发新时代。Agent，作为能够自主理解、规划并执行复杂任务的智能实体，正逐渐从理论走向实践，深刻改变着开发者与代码交互的方式。从最初的单体 Agent 辅助编码，到如今由多个专业 Agent 协同作战，多 Agent 系统（Multi-Agent Systems）已成为提升开发效率、解决复杂软件工程问题的关键。</summary>
    
    
    
    <category term="技术" scheme="https://hbuzxl.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>2025年终总结</title>
    <link href="https://hbuzxl.github.io/2025-year-review/"/>
    <id>https://hbuzxl.github.io/2025-year-review/</id>
    <published>2025-12-31T16:54:15.000Z</published>
    <updated>2026-01-16T09:50:02.867Z</updated>
    
    <content type="html"><![CDATA[<p>很多人对每年的最后一天似乎都有一种执念，仿佛这一天本身被赋予了某种特殊的意义，驱使大家出去庆祝。但时间本身并不会因为日期的变化而产生任何不同，时间的长度没有变，流速也没有变。</p><p>不过它依然是一个很好的节点，可以让人们在这一天，停下来，回望过去走过的一年。也借这个机会，简单回望一下我的2025年</p><h2 id="关于科研"><a href="#关于科研" class="headerlink" title="关于科研"></a>关于科研</h2><p>上半年的主要精力都是放在了论文上面，从读研以来，我就感觉自己并不适合做科研。看论文对我来说是一件很痛苦的事情，搞科研真的是一件没有正反馈的事情，投入了大量时间，最后也不一定有结果，甚至是搞了很久才发现类似的工作别人已经做过了。和工程相比，这种高度不确定性让我非常不适应。</p><p>在论文最焦虑的那段时间，我一直担心自己无法顺利毕业。同门的进度都比我要快，都在寒假之前已经改完投出去了，只有我的论文卡在原地，老师说过年期间会跟我在线改论文，导致我整个过年期间都是在担惊受怕之中度过。</p><p>但最后论文还是投出去了，而且只经历了一次大修就被录用了，很出乎我的意料，真的很幸运，在实习的时候收到录用邮件，如释重负，终于可以顺利毕业了，读研三年也是留下来了一些东西，并没有虚度光阴。</p><p>回过头看，写论文搞科研也挺简单的，并没有想象中的那么复杂，只是身在其中的时候是无法体会到这一点的。</p><p>这里附上论文链接，这大概是科研经历的结尾。</p><ul><li><strong>X. Zhang</strong>, M. Wang, M. Wang, L. Wang, and H. Zhang, Enhanced RIS-assisted vehicular network with TDMA and Bayesian Compressive Sensing-based channel estimation, Computer Networks, p. 111525, 2025. (<strong>CCF-B</strong>), <a href="https://www.sciencedirect.com/science/article/abs/pii/S138912862500492X">link</a></li></ul><h2 id="关于工作"><a href="#关于工作" class="headerlink" title="关于工作"></a>关于工作</h2><p>在论文投出去之后的下半年，都处在工作和找工作的路上。</p><p>从4月份开始投递暑期实习，大大小小经历了20次面试之后，直到放假之前，才获得了一家杭州公司的offer。</p><p>在杭州这段时间，整体节奏是相对轻松的，公司规模不大很清闲，实习生的工作量也不算多，在空间时间看完了好几本书。</p><p>杭州湿热的气候真的是有点无法适应，不过杭州绿化非常好到处都是绿油油的，让人看了就很舒服。生活节奏也比较慢，自己周末都会去周围逛逛，也去爬了两次山，杭州的山真的好多。</p><p>到八月份开始重新投简历，面试很多，基本是上午一场下午一场，还好mentor和leader都很好，并没有说什么，最终在拿到了长亭科技的offer之后，结束了这一段实习。</p><p>其实在暑期之前，我也投过长亭，但是在一面的时候被挂掉了，那次的面试我感觉自己答的非常不错，面试官人也非常好，最后没有通过多少是有些遗憾的。所以在8月底再次拿到长亭的offer之后，一方面是为了弥补之前的遗憾，另一方面也是因为上次的面试官给我留下了不错的印象，对这个公司始终带着一点好感。</p><p>真正进入长亭实习之后，最大的感受就是压力有点大，这种压力并不是来自工作时长，更多是工作氛围本身。刚入职时没有实习搭子，没有人可以交流讨论，很多问题只能自己钻研，那段时间一直处于一种极不适应的状态。</p><p>由于工作压力比较大，上班时间没有时间面试，下班回来也只想躺着休息，导致几乎完全错过了整个秋招。</p><p>好在最后转正答辩顺利通过了，也算对2025画上了一个相对完整的句号。</p><p><img src="/vx_images/320548995056827.png"></p><h2 id="书与电影"><a href="#书与电影" class="headerlink" title="书与电影"></a>书与电影</h2><p>今天陆陆续续也看了不少书和电影，加起来大概四十多部。</p><p>自己最喜欢的是《Hamilton》，第一次接触这种音乐剧，里面的音乐真的是非常喜欢，音频提取出来放在耳机里面也反复听了好多遍，给人一种力量感。</p><p>技术方面的书籍最推荐的是《MySQL是怎样运行的—从根上理解MySQL》和《Redis设计与实现》，这两本书真的很好，强烈推荐，直接提高了我看书的眼光，导致后面再看其他的专业书籍看了几章就看不下去了，总是不自觉的跟这两本书进行对比，感觉写的实在是太烂了</p><p>看完了英文本的《The Three Body Problem 1》，今天只看了这一部英文书籍，感觉自己的英文阅读能力有一定的提升，平时看一些英文资料的时候，直接阅读英文也是可以完全读懂的，但是自己还是不自觉的将他们翻译成中文再看，李笑来说感觉痛苦是大脑重塑神经细胞的过程，只要坚持下来，就下来就会适应英文。新的一年要尽可能直接阅读原版英文</p><ol><li>2025.1.30 - 好东西</li><li>2025.3.2 - 流氓读书会</li><li>2025.3.15 - 人体器官交易实录</li><li>超级工厂- 波音</li><li>2025.3.29 - Hamilton </li><li>2025.3.20 - 《go语言编程》- 许式伟&#x2F;吕桂华</li><li>2025.4.4 - 生活多美好</li><li>2025.4.13 - 蚁人3</li><li>2025.4.16 - The.Flying.Scotsman 苏格兰飞人</li><li>2025.4.19 - 拾荒者统治</li><li>2025.4.27 - Finding Vivian Maier，寻找薇薇安·迈尔</li><li>2025.6.30 - 《赚钱的艺术》 - 蔡澜</li><li>2025.7.9 -《Go程序员面试笔试宝典》- 饶全成、欧长坤</li><li>2025.7.31 -《MySQL是怎样运行的—从根上理解MySQL》- 小孩子4919</li><li>2025.8.4 -《Redis设计与实现》- 黄健宏</li><li>2025.8.31 -《挪威的森林》- 村上春树</li><li>2025.9.21 - 新世界</li><li>2025.11.2 -《人妻约会指南》- 李新野</li><li>2025.11.6 -《消息队列高手课 — 极客时间》- 李玥</li><li>2025.11.8 -《台北人》- 白先勇</li><li>2025.11.16 -《白色巨塔》- 山崎丰子 - 东方出版社</li><li>2025.11.22 -《吃佛: 從一座城市窺見西藏的劫難與求生》- 芭芭拉．德米克</li><li>2025.11.26 - 《后端技术面试38讲——极客时间》- 李智慧</li><li>2025.11.29 -《奇特的一生》- 达尼伊尔·格拉宁</li><li>2025.12.3 -《无声告白》− 伍绮诗</li><li>2025.12.1 - 《The Three Body Problem 1》- 刘慈欣</li></ol><p>今年买的最值的电子产品是 Kindle KPW4了，11月初从咸鱼三百块入手，越狱之后安装了Koreader，目前已经阅读了55个小时。第一次用墨水屏幕的产品，关灯之后发现竟然什么都看不见，大吃一惊，上网搜索才发现是因为墨水屏本身并不发光，主要是靠环境光的反射。</p><p>虽然感觉自己看了很多书，但是并没有深入的消化理解，只是单纯为了读而读，有时候眼睛已经机械式的扫过了一页，突然发现这一页讲了什么，自己并没有什么特别深的印象。接下来的一年希望自己重拾博客，多写一些的思考和读书笔记。</p><table><thead><tr><th align="center"><img src="/vx_images/588763944602900.png" alt="图片1"></th><th align="center"><img src="/vx_images/165426720508225.png" alt="图片2"></th></tr></thead></table><h2 id="健康"><a href="#健康" class="headerlink" title="健康"></a>健康</h2><p>十月份的时候眼睛特别不舒服，一直流眼泪，而且有异物感，去医院检查了一下眼睛，医生说只是干眼症，用眼疲劳，问题不大，多注意休息就好，开了两瓶海露。顺便还检查了一下视力，可喜的是，我的视力并没有增长，两只眼睛都在175度左右，高中毕业以后，因为不舒服就没有再戴过眼镜，加上长时间的看电脑看手机，我以为度数会增长很多。这算是一个好消息吧</p><p>除了眼睛，我也明显感觉到自己的脖子脊椎时常感觉疲劳，可能是工作久坐的原因。另外就是住的地方有一套舒服的桌椅真的很重要，晚上回来不想学习，不想投简历，我感觉很重要的一部分原因就是出租屋的桌椅很不舒服</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>今年自己成长最大的地方就是不再那么在意别人的想法和目光了，以前自己做一件事情，会反复揣度别人会如何看自己，但是今年我已经慢慢不再在意别人的想法了，做事情的时候，会告诉自己，我当时那样做是因为我确实需要那样做，所以才那样做。</p><p>今年做的另一件事情是朋友圈屏蔽了很多人，并不是因为讨厌谁，而是慢慢感觉到注意力是一种很稀缺的资源，自己本身不是一个能量特别充沛的人，不希望被太多无关的人和事情消耗自己。朋友圈本身就是一个很“失真”的地方，里面所展示的并未必是真实的，很多人大概率也不会有交集，关注他们的动态似乎并没有什么意义。</p><p>我自己也已经很少发朋友圈了，有时候我想发一些自己的猫猫狗狗，但是感觉好幼稚，都已经二十大几了，还发这些，别人不会理解我的，但是人是拥有表达欲望的，朋友圈不发肯定也会在其他地方表达。我的一些日常的分享主要集中在微博上面，但是微博的审核机制也很恶心，而且数据无法掌握在自己手中，感觉不安心，有时候打算抛弃微博，转战推特，但是推特的长文机制不是很完善。可能今后会转移到自己的blog中</p><p>今年还系统的学习了 Vim 编辑模式，越用越顺手，也逐渐喜欢上了这种编辑模式，甚至想买一把 HHKB</p><p>周围的朋友陆陆续续都在结婚，对于感情这件事，我其实是很向往的，希望有一个人可以陪伴自己聊聊天，说说话，分享一些日常的碎片，毕竟一个人有时候真的过于无聊了。虽然向往，但是如果让我立马结婚，还是感觉自己没有真正的准备好，无论是从心态上还是从承担起一个家庭的能力。</p><h2 id="新年flag"><a href="#新年flag" class="headerlink" title="新年flag"></a>新年flag</h2><p>啰里啰唆也是写了很多，很琐碎，很私人，恨不得把所有事情都写上去，这不像我想象中的年度总结，年度总结应当是感悟，而不是事情的简单堆叠。我的语言表达功力还是有所欠缺，往年也写过年度总结，但是表达出来的内容过于私人化了，不太适合发表出来，但是总要有一个开始吧，我相信只要多写一写，文笔总会变好的，希望明年的年度总结会比今年好一些。</p><ul><li>找到一个心仪的工作</li><li>打算主力IDE转移到 Neovim</li><li>希望可以出去看看世界是什么样子的，有机会去一趟日本</li><li>考一本摩托驾照</li><li>多多出去拍照</li><li>发布12篇blog，争取一月一篇</li><li>至少看一本英文书</li><li>实现自己的 side project</li></ul><p>再见2025，你好2026，最后祝大家新年快乐！</p>]]></content>
    
    
    <summary type="html">很多人对每年的最后一天似乎都有一种执念，仿佛这一天本身被赋予了某种特殊的意义，驱使大家出去庆祝。但时间本身并不会因为日期的变化而产生任何不同，时间的长度没有变，流速也没有变。不过它依然是一个很好的节点，可以让人们在这一天，停下来，回望过去走过的一年。也借这个机会，简单回望一下我的2025年</summary>
    
    
    
    <category term="年终总结" scheme="https://hbuzxl.github.io/categories/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    
    
  </entry>
  
  <entry>
    <title>观影报告:触不可及</title>
    <link href="https://hbuzxl.github.io/movie-review-intouchables/"/>
    <id>https://hbuzxl.github.io/movie-review-intouchables/</id>
    <published>2022-01-09T07:55:28.000Z</published>
    <updated>2026-01-16T09:50:02.868Z</updated>
    
    <content type="html"><![CDATA[<p>今天一天都不想学习，不，应该说好久没有学习了。唉，学习真是一件令人痛苦的事情啊。也不知道干什么，于是找了一部电影看，看见这部评分特别高，于是就看了一下。</p><p>非常棒，跟绿皮书有异曲同工之妙，我在看的时候一直想要找到电影的封面，但却一直没有看到那个画面。后来翻看评论区才知道我看的是美版的《触不可及》，是翻拍的法国的电影。</p><p>想要写些什么，却发现我的文笔和表达如此之烂，丝毫不知道要说些什么。</p><p>只能肤浅的说一下，里面的女管家真的演技挺好的，我也挺喜欢这个角色的，尤其是一些小表情，我好喜欢。。里面的康复心理学家也好好看，虽然有些黑，但又恰到好处。</p><p>其中感觉有些地方不太真实，在Dell被解雇之后，拿着5000美元的启动资金，买（或者是租的）了一套大房子，然后开了一家轮椅研究工厂，并看起来运营的还不错，这很难让我将之放到一个入狱数次，前科恶行多端的人身上去；这一点跟《我不是药神》里的徐峥后面开服装厂，短短几年，风生水起，创业这么容易的嘛，我想不是这样的。</p><p>同时感觉Dell妻子非常的势利、爱慕虚荣，有钱了就接受你，让你去接儿子放学；没钱了，就不让爸爸去见儿子。。总之，挺不喜欢这个角色的。而Dell却在离婚之后仍然很好地紧着父亲的责任，还在想着儿子的生日，甚至自己的工资一发放就给妻儿送过去。两相对比之下，我不太理解，二人性格差距如此之大，如何能够生活在一起呢。</p><p>还有一点，当Dell向儿子索要那本书时，儿子所表现出来的态度也着实让人感到很无语。对于父亲的老板，对于一个刚刚还在请自己吃冰淇淋的长辈，对于一个改过自新的父亲，在父亲的老板面前说出如此的话，让我感觉这个儿子很没有教养，一点也不体谅、换位思考自己的父亲。</p><p>不过最后，管家和老板能够在一起真的也算是挺圆满了。不过，我有些搞不懂，哈弗毕业，如此优秀的一个女生，为啥会看上这个全身瘫痪的老头子呢，借用电影中的话：Why?（图什么呢）我不太愿意相信管家贪图的是老板的钱财，我相信她不是这样的人，那究竟是为什么呢，只能用所谓的纯真的爱情来解释了</p>]]></content>
    
    
    <summary type="html">今天一天都不想学习，不，应该说好久没有学习了。唉，学习真是一件令人痛苦的事情啊。也不知道干什么，于是找了一部电影看，看见这部评分特别高，于是就看了一下。非常棒，跟绿皮书有异曲同工之妙，我在看的时候一直想要找到电影的封面，但却一直没有看到那个画面。后来翻看评论区才知道我看的是美版的《触不可及》，是翻拍的法国的电影。</summary>
    
    
    
    <category term="书与电影" scheme="https://hbuzxl.github.io/categories/%E4%B9%A6%E4%B8%8E%E7%94%B5%E5%BD%B1/"/>
    
    
    <category term="电影" scheme="https://hbuzxl.github.io/tags/%E7%94%B5%E5%BD%B1/"/>
    
  </entry>
  
</feed>
